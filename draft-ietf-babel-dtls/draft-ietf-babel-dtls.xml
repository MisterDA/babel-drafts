<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC6126 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6126.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="info" docName="draft-ietf-babel-dtls" ipr="trust200902">
<front>
<title>Babel Routing Protocol over DTLS</title>
<author fullname="Antonin Decimo" initials="A." surname="Decimo">
<organization></organization>
<address>
<postal>
<street></street>
<city>Paris</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email></email>
</address>
</author>

<date year="2018" />

<abstract>
<t>The Babel routing protocol has no built-in security mechanism.  We
describe methods to secure Babel with DTLS.</t>
</abstract>
</front>

<middle>

<section title="Introduction">

<t>The Babel routing protocol <xref target="RFC6126"></xref> has no
built-in security mechanism.  We describe methods to secure Babel with
DTLS <xref target="RFC6347"></xref>.  The motivations for proposing
Babel over DTLS are that:
<list style="symbols">
<t>DTLS provides a sub-layer of security that is well-defined and has
various implementations, and does not require changes in the Babel
protocol.</t>
<t>DTLS allows the use of asymmetric keys</t>
</list>
</t>

</section>

<section title="Operation of the protocol">

<section title="DTLS Handshake">

<t>When a peer A receives a packet incoming from a new neighbour B,
then:
<list style="symbols">
<t>if the link-local address of A is inferior of the link-local
address of B, A initializes its DTLS state as a server for the peer
B</t>
<t>else, initializes its DTLS state as a server for the peer B, and
starts the DTLS handshake</t>
</list>
If the handshake succeeds, the peers run Babel as usual over DTLS.
Else, refer to the DTLS RFC (possibly free the DTLS state for the
neighbour).</t>

</section>

<section title="DTLS State Removal">

<t>If two peers A and B have an existing DTLS connection, and A
receives a packet from B that A can not decrypt (B may have rebooted),
then:
<list style="symbols">
<t>either the DTLS state of A for B is discarded,</t>
<t>either we try to follow the DTLS RFC</t>
</list>
XXX: should we maintain two DTLS states?</t>

</section>

<section title="Emission">

<t>DTLS can not secure multicast.  All packets send via unicast must
be protected by DTLS.  Only Hello, IHU, or TLVs containing
non-sensitive data are allowed to be send in clear via multicast.</t>

</section>

<section title="Reception">

<t>A unprotected packet received can be parsed, but peers may choose
not take action on the content of the packet.  A peer using Babel over
DTLS must not take action on the content of an unencrypted packet,
unless the TLVs are Hello, IHU, or TLVs containing non-sensitive
information.</t>

</section>

</section>

<section title="Cooperation with Babel">

<section title="Peer-to-peer on the same port">

<t>Babel and DTLS traffic is received on the same socket.  The DTLS
client port, the DTLS server port, and the Babel port are the same.
When a packet is received, it is treated as a DTLS packet and
decrypted.
<list style="symbols">
<t>if the decryption is successful, the packet is parsed as a Babel
packet and the peer takes action on its content.</t>
<t>if not, the packet is parsed as a Babel packet and the peer may
only take action on non-sensitive data.</t>
</list>
</t>

</section>

<section title="Peer-to-peer on another port">

<t>A new port is used for Babel over DTLS traffic.  Question: are the
client port and the server port the same?</t>

</section>

<section title="Client / Server model">

</section>

</section>

</middle>

<back>

<references title="Informative References">
&RFC6126;
&RFC6347;
</references>

</back>

</rfc>
